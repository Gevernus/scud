require('dotenv').config();
const express = require('express');
const mongoose = require('mongoose');
const cors = require("cors");
const crypto = require('crypto');
const jwt = require('jsonwebtoken');
const User = require('./models/User');
const Event = require('./models/Event');
const Station = require('./models/Station')
const Counterparty = require('./models/Counterparty')
const { startOfDay, endOfDay, startOfWeek, startOfMonth, toDate } = require("date-fns");

const app = express();
app.use(cors({
    exposedHeaders: ['Content-Range']
}));
app.use(express.json());

// MongoDB connection
mongoose.connect(process.env.MONGO_URI)
    .then(() => console.log('MongoDB connected'))
    .catch(err => console.error(err));

// app.post("/api/front/users", async (req, res) => {
//     const { telegramId, firstName, lastName, username, linkHash } = req.body;

//     try {
//         // Check if user exists
//         let user = await User.findOne({ telegramId });

//         if (!user) {
//             // Create new user
//             user = new User({
//                 telegramId,
//                 firstName,
//                 lastName,
//                 username,
//             });
//             await user.save();

//             // // Update referrer's referrals array if referral exists
//             // if (linkHash) {
//             //     const shareLink = await ShareLink.findOne({
//             //         hash: linkHash,
//             //     });

//             //     if (shareLink) {
//             //         await User.findByIdAndUpdate(shareLink.userId, {
//             //             $push: {
//             //                 referrals: {
//             //                     userId: user._id,
//             //                     createdAt: new Date()
//             //                 }
//             //             }
//             //         });
//             //     }
//             // }
//         }

//         res.json(user);
//     } catch (error) {
//         console.error("Error in /api/front/users:", error);
//         res.status(500).json({ error: "Internal server error" });
//     }
// });


app.post("/api/front/users", async (req, res) => {
    const { telegramId, firstName, lastName, username } = req.body;

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ –±–∞–∑–µ
        const userCount = await User.countDocuments();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
        let user = await User.findOne({ telegramId });

        if (!user) {
            // –ü–µ—Ä–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∞–µ—Ç –∞–¥–º–∏–Ω—Å–∫–∏–µ –ø—Ä–∞–≤–∞
            user = new User({
                telegramId,
                firstName,
                lastName,
                username,
                permissions: userCount === 0 ? 98303 : 0, 
            });

            await user.save();
        }

        res.json(user);
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –≤ /api/front/users:", error);
        res.status(500).json({ error: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
});


//–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ –∞–¥–º–∏–Ω–∫–∏
app.post("/api/admin/auth/check", async (req, res) => {
    const { telegramId } = req.body;

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤ –±–∞–∑–µ
        const user = await User.findOne({ telegramId });

        if (!user) {
            return res.status(404).json({ error: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω" });
        }

        res.json(user);
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:", error);
        res.status(500).json({ error: "–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞" });
    }
});

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏—è
const registerEvent = async ({ eventType, description }) => {
    try {
        const event = new Event({
            eventType,
            description,
        });

        await event.save();
        return event;
    } catch (err) {
        console.error("–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏—è:", err);
        throw err;
    }
};

// –≠–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ —Å–æ–±—ã—Ç–∏—è
app.post("/api/front/events", async (req, res) => {
    const { eventType, description } = req.body;
    try {
        // –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ —Ñ—É–Ω–∫—Ü–∏—è —Å–∞–º–æ—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ –Ω–∞–π–¥—ë—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ telegramId
        const event = await registerEvent({ eventType, description });
        res.status(201).json({ message: "Event recorded successfully", event });
    } catch (error) {
        console.error("Error in /api/front/events:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

//—Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏–π —É–¥–∞–ª–µ–Ω–∏—è
const logDeletion = async (Model, item) => {
    let description = "";

    switch (Model.modelName) {
        case "User": {
            const user = await User.findById(item._id);
            if (user) {
                description = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${user.firstName || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} ${user.lastName || ""} (Telegram ID: ${user.telegramId}) –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            } else {
                description = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            }
            break;
        }
        case "Station": {
            const station = await Station.findById(item._id);
            if (station) {
                description = `–°—Ç–∞–Ω—Ü–∏—è ${station.name || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} (IP: ${station.ip || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}) –±—ã–ª–∞ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            } else {
                description = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è –±—ã–ª–∞ –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω–∞ –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            }
            break;
        }
        case "Counterparty": {
            const —Åounterparty = await Counterparty.findById(item._id);
            if (—Åounterparty) {
                description = `–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç ${—Åounterparty.fullName || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} (Id: ${—Åounterparty.counterpartyId || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}) –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            } else {
                description = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –∫–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            }
            break;
        }
        default:
            description = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ ${Model.modelName} –±—ã–ª –ø–µ—Ä–µ–Ω–µ—Å–µ–Ω –≤ –∫–æ—Ä–∑–∏–Ω—É.`;
            break;
    }

    await registerEvent({
        eventType: "soft_delete",
        description
    });
};

const logPermanentDeletion = async (Model, item) => {
    let description = "";
    switch (Model.modelName) {
        case "User": {
            description = `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${item.firstName || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} ${item.lastName || ""} (Telegram ID: ${item.telegramId}) –±—ã–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω.`;
            break;
        }
        case "Station": {
            description = `–°—Ç–∞–Ω—Ü–∏—è ${item.name || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} (IP: ${item.ip || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}) –±—ã–ª–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞.`;
            break;
        }
        case "Counterparty": {
            description = `–ö–æ–Ω—Ç—Ä–∞–≥–µ–Ω—Ç ${item.fullName || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"} (Id: ${item.counterpartyId || "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ"}) –±—ã–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω.`;
            break;
        }
        default:
            description = `–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–±—ä–µ–∫—Ç —Ç–∏–ø–∞ ${Model.modelName} –±—ã–ª –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω.`;
            break;
    }

    await registerEvent({
        eventType: "full_delete",
        description
    });
};
// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –º–∞—Ä—à—Ä—É—Ç–æ–≤ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞
const handleAdminRoute = (Model, resourceName, additionalFilter = {}) => async (req, res) => {
    try {
        let filter = req.query.filter ? JSON.parse(req.query.filter) : {};
        filter = { ...filter, ...additionalFilter };

        const now = new Date();

        // üìå –ü–æ–ª—É—á–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –æ—Ç –∫–ª–∏–µ–Ω—Ç–∞ (–≤ –º–∏–Ω—É—Ç–∞—Ö) –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥—ã
        const timezoneOffset = req.headers["x-timezone-offset"] ? parseInt(req.headers["x-timezone-offset"]) * 60000 : 0;

        // üìå –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –¥–∞—Ç—É –æ–¥–∏–Ω —Ä–∞–∑!
        const toUTC = (date) => new Date(date.getTime() + timezoneOffset); // –°–¥–≤–∏–≥–∞–µ–º –≤—Ä–µ–º—è –Ω–∞–∑–∞–¥ –≤ UTC

        // üîπ –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º (—Å–µ–≥–æ–¥–Ω—è, –Ω–µ–¥–µ–ª—è, –º–µ—Å—è—Ü)
        if (filter.dateRange) {
            let start, end;
            switch (filter.dateRange) {
                case 'today':
                    start = toUTC(startOfDay(now)).toISOString(); // –ù–∞—á–∞–ª–æ –¥–Ω—è –≤ UTC
                    end = toUTC(endOfDay(now)).toISOString(); // –ö–æ–Ω–µ—Ü –¥–Ω—è –≤ UTC
                    break;
                case 'week':
                    start = toUTC(startOfWeek(now, { weekStartsOn: 1 })).toISOString();
                    end = toUTC(endOfDay(now)).toISOString();
                    break;
                case 'month':
                    start = toUTC(startOfMonth(now)).toISOString();
                    end = toUTC(endOfDay(now)).toISOString();
                    break;
                default:
                    break;
            }

            if (start && end) {
                filter.createdAt = { $gte: start, $lte: end };
            }

            delete filter.dateRange;
        }

        // üîπ –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É –¥–∞—Ç
        if (filter.startDate || filter.endDate) {
            let startDate = filter.startDate ? toUTC(startOfDay(new Date(filter.startDate))).toISOString() : null;
            let endDate = filter.endDate ? toUTC(endOfDay(new Date(filter.endDate))).toISOString() : null;

            filter.createdAt = {};
            if (startDate) filter.createdAt.$gte = startDate;
            if (endDate) filter.createdAt.$lte = endDate;

            delete filter.startDate;
            delete filter.endDate;
        }

        // üîπ –õ–æ–≥–∏—Ä—É–µ–º —Ñ–∏–ª—å—Ç—Ä, —á—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –¥–∞—Ç—ã –≤–µ—Ä–Ω—ã–µ
        console.log("–§–∏–ª—å—Ç—Ä –ø–æ –¥–∞—Ç–∞–º (UTC):", filter.createdAt);

        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Å—Ç–æ–ª–±—Ü—É
        if (filter.q && filter.searchField) {
            filter[filter.searchField] = { $regex: filter.q, $options: "i" };
            delete filter.q;
            delete filter.searchField;
        }

        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ id –≤ _id
        if (filter.id) {
            filter._id = filter.id;
            delete filter.id;
        }

        // –†–∞–∑–±–∏—Ä–∞–µ–º —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫—É –∏ –¥–∏–∞–ø–∞–∑–æ–Ω
        const [start, end] = req.query.range ? JSON.parse(req.query.range) : [0, 9];
        let [sortField, sortOrder] = req.query.sort ? JSON.parse(req.query.sort) : ["id", "ASC"];
        if (sortField === "id") sortField = "_id";

        const total = await Model.countDocuments(filter);
        const items = await Model.find(filter)
            .sort({ [sortField]: sortOrder === "ASC" ? 1 : -1 })
            .skip(start)
            .limit(end - start + 1);

        res.set('Content-Range', `${resourceName} ${start}-${Math.min(end, total)}/${total}`);
        res.set('Access-Control-Expose-Headers', 'Content-Range');
        res.json(items);
    } catch (error) {
        console.error("–û—à–∏–±–∫–∞ –≤ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:", error);
        res.status(500).json({ error: error.message });
    }
};

// –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–µ CRUD-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
const handleGetOne = (Model) => async (req, res) => {
    try {
        const item = await Model.findById(req.params.id);
        if (!item) return res.status(404).json({ error: "Not found" });
        res.json(item);
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};


const handleCreate = (Model) => async (req, res) => {
    try {
        const item = new Model(req.body);
        await item.save();
        res.status(201).json(item);
    } catch (error) {
        if (error.code === 11000) {
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫—É —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ (–¥—É–±–ª–∏–∫–∞—Ç)
            return res.status(400).json({ error: "–∑–Ω–∞—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—å—Å—è —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç." });
        }
        res.status(400).json({ error: error.message });
    }
};

const handleUpdate = (Model) => async (req, res) => {
    try {
        const item = await Model.findByIdAndUpdate(req.params.id, req.body, { new: true });
        if (!item) return res.status(404).json({ error: "Not found" });
        res.json(item);
    } catch (error) {
        if (error.code === 11000) {
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –æ—à–∏–±–∫—É —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ (–¥—É–±–ª–∏–∫–∞—Ç)
            return res.status(400).json({ error: "–∑–Ω–∞—á–µ–Ω–∏–µ —è–≤–ª—è–µ—Ç—å—Å—è —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç." });
        }
        res.status(500).json({ error: error.message });
    }
};

const handleDelete = (Model) => async (req, res) => {
    try {
        const item = await Model.findByIdAndUpdate(
            req.params.id,
            { deleted: true },
            { new: true }
        );
        if (!item) return res.status(404).json({ error: "Not found" });

        // –í—ã–∑—ã–≤–∞–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è –º—è–≥–∫–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
        if (Model.modelName !== "Event") {await logDeletion(Model, item)}
    
        res.json({ message: "–£–¥–∞–ª–µ–Ω–æ (soft delete)", item });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

const handleRestore = (Model) => async (req, res) => {
    try {
        const item = await Model.findByIdAndUpdate(
            req.params.id,
            { deleted: false },
            { new: true }
        );
        if (!item) return res.status(404).json({ error: "Not found" });
        res.json({ message: "Restored successfully", item });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

const handlePermanentDelete = (Model) => async (req, res) => {
    try {
        // –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –æ–±—ä–µ–∫—Ç, —á—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å –µ–≥–æ –¥–∞–Ω–Ω—ã–µ (telegramId –∏ _id)
        const item = await Model.findById(req.params.id);
        if (!item) return res.status(404).json({ error: "Not found" });       
        
        // –£–¥–∞–ª—è–µ–º –æ–±—ä–µ–∫—Ç –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ –∏–∑ –±–∞–∑—ã
        await Model.findByIdAndDelete(req.params.id);
        // –í—ã–∑—ã–≤–∞–µ–º —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è —Å–æ–±—ã—Ç–∏—è –ø–æ–ª–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è
        if (Model.modelName !== "Event") {await logPermanentDeletion(Model, item)}
        
        
        res.json({ message: "–ü–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–æ" });
    } catch (error) {
        res.status(500).json({ error: error.message });
    }
};

// –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –∞–¥–º–∏–Ω–∞ (–Ω–µ—É–¥–∞–ª—ë–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã)
app.get("/api/admin/users", handleAdminRoute(User, "users"));
app.get("/api/admin/users/:id", handleGetOne(User, "users"));
app.post("/api/admin/users", handleCreate(User));
app.put("/api/admin/users/:id", handleUpdate(User));
app.delete("/api/admin/users/:id", handleDelete(User));  // –ú—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ

app.get("/api/admin/events", handleAdminRoute(Event, "events"));
app.get("/api/admin/events/:id", handleGetOne(Event, "events"));
app.delete("/api/admin/events/:id", handleDelete(Event));  // –ú—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ

app.get("/api/admin/stations", handleAdminRoute(Station, "stations"));
app.get("/api/admin/stations/:id", handleGetOne(Station));
app.post("/api/admin/stations", handleCreate(Station));
app.put("/api/admin/stations/:id", handleUpdate(Station));
app.delete("/api/admin/stations/:id", handleDelete(Station));  // –ú—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ

app.get("/api/admin/counterparts", handleAdminRoute(Counterparty, "counterparts"));
app.get("/api/admin/counterparts/:id", handleGetOne(Counterparty));
app.post("/api/admin/counterparts", handleCreate(Counterparty));
app.put("/api/admin/counterparts/:id", handleUpdate(Counterparty));
app.delete("/api/admin/counterparts/:id", handleDelete(Counterparty));  // –ú—è–≥–∫–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ

// –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –∫–æ—Ä–∑–∏–Ω–æ–π (—Ç–æ–ª—å–∫–æ —É–¥–∞–ª—ë–Ω–Ω—ã–µ –æ–±—ä–µ–∫—Ç—ã)
app.get("/api/admin/UsersTrash", handleAdminRoute(User, "users", { deleted: true }));
app.get("/api/admin/EventsTrash", handleAdminRoute(Event, "events", { deleted: true }));
app.get("/api/admin/StationsTrash", handleAdminRoute(Station, "stations", { deleted: true }));
app.get("/api/admin/counterpartyTrash", handleAdminRoute(Counterparty, "counterparts", { deleted: true }));

// –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –æ–±—ä–µ–∫—Ç–æ–≤ –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
app.post("/api/admin/trash/users/:id/restore", handleRestore(User));
app.post("/api/admin/trash/events/:id/restore", handleRestore(Event));
app.post("/api/admin/trash/stations/:id/restore", handleRestore(Station));
app.post("/api/admin/trash/counterparts/:id/restore", handleRestore(Counterparty));

// –≠–Ω–¥–ø–æ–∏–Ω—Ç—ã –¥–ª—è –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è –∏–∑ –∫–æ—Ä–∑–∏–Ω—ã
app.delete("/api/admin/usersTrash/:id", handlePermanentDelete(User));
app.delete("/api/admin/eventsTrash/:id", handlePermanentDelete(Event));
app.delete("/api/admin/stationsTrash/:id", handlePermanentDelete(Station));
app.delete("/api/admin/counterpartyTrash/:id", handlePermanentDelete(Counterparty));

app.listen(8000, () => console.log('Backend running on port 8000'));